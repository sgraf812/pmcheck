
%%%%%%%%% HERE THE MACROS START
% Highlight changes and keyword undone
% \newcommand{\highlight}[1]{\colorbox{lightgray}{\ensuremath{#1}}}

\newcommand{\highlight}[1]{\setlength{\fboxsep}{2pt}\colorbox{lightgray}{\ensuremath{#1}}} % less height

\newcommand{\UNDONE}{\begin{color}{red}{\bf UNDONE }\end{color}}
\newcommand{\DONE}{\begin{color}{green}{\bf DONE}\end{color}}
\newcommand{\NOTE}[1]{\bf #1}
\newcommand{\TODO}[1]{{\bf{\begin{color}{red}{TODO: }\end{color} #1}}}
\newcommand{\sysname}{\begin{color}{red}{\bf SYSNAME}\end{color}\xspace}
\newcommand{\gmtm}{GMTM\xspace}
\newcommand{\highlightchange}[1]{\text{\colorbox[gray]{0.8}{#1}}}

\newcommand{\cf}{cf.\@\xspace}
\newcommand{\eg}{e.g.,\@\xspace}
\newcommand{\ie}{i.e.\@\xspace}
\newcommand{\vs}{vs.\@\xspace}
\newcommand{\etc}{etc.\@\xspace}
\newcommand{\keyword}[1]{\textsf{\textbf{#1}}}
\newcommand{\id}[1]{\textsf{\textsl{#1}}\xspace}

% Useful macros that are often needed
\newcommand{\typeeq}{\sim}          % type equality
\newcommand{\termeq}{\approx}       % positive term equality
\newcommand{\ntermeq}{\not\approx}  % negative term equality

\newcommand{\ruleform}[1]{\fbox{$#1$}}
\newcommand{\rulename}[1]{\textsc{[#1]}}

\newcommand{\ticket}[1]{\href{https://ghc.haskell.org/trac/ghc/ticket/#1}{\##1}}
\newcommand{\extension}[1]{\texttt{#1}}

\newcommand{\sg}[1]{\begin{color}{red}{\bf SG:} #1\end{color}}
\newcommand{\simon}[1]{\begin{color}{purple}{\bf SLPJ:} #1\end{color}}
\newcommand{\ryan}[1]{\begin{color}{orange}{\bf Ryan:} #1\end{color}}


% Types and Grd syntax
\newcommand{\ty}[1]{\textsf{#1}\xspace}
\newcommand{\Pat}{\ty{Pat}}
\newcommand{\Grd}{\ty{Grd}}
\newcommand{\Con}{\ty{Con}}
\newcommand{\Var}{\ty{Var}}
\newcommand{\Expr}{\ty{Expr}}
\newcommand{\Type}{\ty{Type}}
\newcommand{\Kind}{\ty{Kind}}
\newcommand{\TyCt}{\ty{TyCt}}
\newcommand{\PS}{\ty{PS}}
\newcommand{\CL}{\ty{CL}}
\newcommand{\grdlet}[2]{\textsf{let}\;#1\,\textsf{=}\,#2}
\newcommand{\grdbang}[1]{\textsf{!}#1}
\newcommand{\grdcon}[2]{#1 \leftarrow #2}
\newcommand{\ctlet}[2]{\textsf{let}\;#1\,\textsf{=}\,#2}
\newcommand{\ctcon}[2]{#1 \leftarrow #2}
\newcommand{\genconapp}[4]{#1\;\overline{#2}\;\overline{#3}\;\overline{#4}}
\newcommand{\expconapp}[5]{#1\;\overline{#2}\;\overline{#3}\;\overline{#4}\;\overline{#5}}
\newcommand{\deltaconapp}[3]{#1\;\overline{#2}\;\overline{#3}}
\newcommand{\false}{\times}
\newcommand{\true}{\checked}

% GrdTree Gdt
\newcommand{\Gdt}{\ty{Gdt}}
\newcommand{\gdtrhs}[1]{\texttt{Rhs} \; #1}
\newcommand{\gdtseq}[2]{#1; #2}
\newcommand{\gdtguard}[2]{\texttt{Guard} \; #1 \; #2}
\newcommand{\gdtempty}{\texttt{Empty}}

% AnnTree Ant
\newcommand{\Ant}{\ty{Ant}}
\newcommand{\antred}[1]{\texttt{InaccessibleRhs} \; #1}
\newcommand{\antrhs}[1]{\texttt{AccessibleRhs} \; #1}
\newcommand{\antseq}[2]{#1; #2}
\newcommand{\antdiv}[1]{\texttt{MayDiverge} \; #1}
\newcommand{\antempty}{\texttt{AntEmpty}}

% Graphic notation for trees
\forestset{%
  clausetree/.style={
    for tree={
      grow'=0,
      align=left,
      calign=first,
      anchor=west,
      line width=0.2mm,
      inner sep=2pt,
      s sep=0pt,
      delay={edge={line width=0.2mm}}},
    forked edges
  },
  grdtree/.style={
    clausetree,
    guards/.style={edge={-Bar}},
    %grhs/.style={tier=rhs,edge={->,decorate,decoration={snake,post length=2pt,amplitude=0.8pt}}}, % experimental squiggly arrow
    grhs/.style={tier=rhs,edge={->}},
    % Everything except the root and the leaves is guards
    for descendants={delay={if n children=0{grhs}{guards}}}
  },
  anttree/.style={
    clausetree,
    acc/.style={tier=rhs,edge={->},edge label={node[above]{$\checked$}}},
    inacc/.style={tier=rhs,edge={->},edge label={node[above]{$\times$}}},
  },
}

% Desugaring function
\newcommand{\ds}{\mathcal{D}}

% Checking functions
\newcommand{\unc}{\mathcal{U}}
\newcommand{\ann}{\mathcal{A}}
\newcommand{\red}{\mathcal{R}}
\newcommand{\uncann}{\unc\hspace{-0.35em}\ann}

% Refinement type functions
\newcommand{\generate}{\mathcal{G}}
\newcommand{\construct}{\mathcal{C}}
\newcommand{\expand}{\mathcal{E}}

% Refinement type syntax
\newcommand{\reft}[2]{\{ \, #1 \mid #2 \, \}}
\newcommand{\andtheta}{\,\dot{\wedge}\,}
\newcommand{\uniontheta}{\,\cup\,}

% Inert sets
\newcommand{\inert}[1]{I#1}
\newcommand{\ctxt}[2]{#1 \triangleright #2}
\newcommand{\adddelta}{\,\oplus_{\delta}\,}
\newcommand{\addphi}{\,\oplus_{\varphi}\,}
\newcommand{\inhabited}[2]{#1 \vdash #2}
\newcommand{\inhabitedbot}{\textsc{$\vdash$Bot}\xspace}
\newcommand{\inhabitednocpl}{\textsc{$\vdash$NoCpl}\xspace}
\newcommand{\inhabitedinst}{\textsc{$\vdash$Inst}\xspace}
\newcommand{\cons}{\mathsf{Cons}}
\newcommand{\inst}{\mathsf{Inst}}
\newcommand{\rep}[2]{#1(#2)}
\newcommand{\addphiv}{\,\dot{\oplus}_{\varphi}\,} % "Vectorised" \addphi, hence \addphiv
\newcommand{\throttle}[2]{\left\lfloor#2\right\rfloor_{#1}}
